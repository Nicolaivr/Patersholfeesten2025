<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Patersholfeesten 2025 - Festival Tijdlijn</title>
  <link href="https://fonts.googleapis.com/css?family=Montserrat:700,400&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Montserrat', Arial, sans-serif;
      background: #f5f7fb;
      margin: 0;
      padding: 0;
      color: #222;
    }
    header {
      background: #2e3d51;
      color: #fff;
      padding: 2rem 1rem 1rem 1rem;
      text-align: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }
    header h1 {
      margin: 0;
      font-size: 2.5rem;
      font-weight: 700;
      letter-spacing: 2px;
    }
    header p {
      margin: 0.5rem 0 0 0;
      font-size: 1.15rem;
      font-weight: 400;
    }
    .timeline-container {
      max-width: 1300px;
      margin: 2rem auto;
      padding: 0 1rem;
    }
    .timeline-date {
      font-size: 1.4rem;
      font-weight: 700;
      color: #2e3d51;
      margin: 2.5rem 0 1rem 0;
      border-left: 5px solid #2e3d51;
      padding-left: 0.8em;
      background: #ebeff5;
    }
    .timeline-grid-wrap {
      position: relative;
    }
    .timeline-grid {
      display: grid;
      grid-template-columns: 80px repeat(var(--stage-count), 1fr);
      gap: 0;
      border-radius: 8px;
      background: #fff;
      box-shadow: 0 2px 8px rgba(0,0,0,0.03);
      overflow: visible;
      position: relative;
    }
    .timeline-header {
      background: #e3eaf4;
      color: #2e3d51;
      font-weight: 600;
      text-align: center;
      padding: 0.6em 0.2em;
      border-bottom: 1px solid #d9e3f0;
      font-size: 1.05rem;
      position: sticky;
      top: 0;
      z-index: 2;
    }
    .timeline-time {
      background: #f5f7fb;
      font-weight: 600;
      font-size: 1.02em;
      color: #2e3d51;
      text-align: right;
      padding: 0.4em 0.8em 0.4em 0.2em;
      border-right: 1px solid #e3eaf4;
      border-bottom: 1px solid #e3eaf4;
      min-height: 2.5em;
      box-sizing: border-box;
      position: relative;
      z-index: 1;
    }
    .timeline-cell {
      border-bottom: 1px solid #e3eaf4;
      min-height: 2.5em;
      padding: 0;
      box-sizing: border-box;
      position: relative;
      background: #fff;
      z-index: 1;
    }
    .event-stack {
      display: flex;
      height: 100%;
      gap: 0.2em;
      align-items: stretch;
      width: 100%;
    }
    .timeline-event {
      flex: 1 1 0;
      display: flex;
      flex-direction: column;
      margin: 0.1em 0.1em;
      border-radius: 5px;
      overflow: hidden;
      border: 1px solid #ddd;
      min-width: 0;
      background: #fafcff;
      position: relative;
      z-index: 3;
    }
    .timeline-event.stage-kaatsspelplein { border-left: 5px solid #1abc9c; background: #eafaf5; border-color: #1abc9c; }
    .timeline-event.stage-viersprong { border-left: 5px solid #e67e22; background: #fcf3eb; border-color: #e67e22; }
    .timeline-event.stage-algemeen { border-left: 5px solid #2e3d51; background: #f2f5fa; border-color: #2e3d51; }
    .event-title { font-weight: bold; font-size: 1.01em; }
    .event-info { font-size: 0.95em; color: #445; }
    .event-time { font-size: 0.92em; font-style: italic; color: #555; }
    .now-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 2.5px;
      background: red;
      z-index: 10;
      pointer-events: none;
      transition: top 0.2s;
    }
    @media (max-width: 800px) {
      .timeline-header, .timeline-time, .timeline-cell, .timeline-event { font-size: 0.97rem; }
      header h1 { font-size: 2rem; }
      .timeline-container { padding: 0 0.2rem; }
      .timeline-grid { font-size: 0.93rem; }
    }
    @media (max-width: 600px) {
      .timeline-grid { font-size: 0.88rem; }
      .timeline-header { font-size: 0.94rem; }
    }
  </style>
</head>
<body>
  <header>
    <h1>Patersholfeesten 2025</h1>
    <p>Festival Tijdlijn &mdash; Overzicht per dag en per podium</p>
  </header>
  <main>
    <div class="timeline-container" id="timeline"></div>
  </main>
  <script>
    // Utility functions
    function padTime(t) {
      return t.length === 5 ? t : t.length === 4 ? '0' + t : t;
    }
    function timeToMinutes(t) {
      const [h, m] = t.split(':').map(Number);
      return h * 60 + m;
    }
    function minutesToTime(m) {
      const h = Math.floor(m / 60);
      const mm = m % 60;
      return h.toString().padStart(2, '0') + ':' + mm.toString().padStart(2, '0');
    }
    function createTimeSlots(events, slotMinutes = 30) {
      let min = '24:00', max = '00:00';
      for (const ev of events) {
        if (padTime(ev.start) < min) min = padTime(ev.start);
        if (padTime(ev.end) > max) max = padTime(ev.end);
      }
      min = padTime(min);
      max = padTime(max);
      const slots = [];
      let cur = timeToMinutes(min);
      const end = timeToMinutes(max);
      while (cur <= end) {
        slots.push(minutesToTime(cur));
        cur += slotMinutes;
      }
      return slots;
    }
    function getAllStages(events) {
      const stageSet = new Set(events.map(ev => ev.stage));
      const order = ['kaatsspelplein', 'viersprong', 'algemeen'];
      const stages = Array.from(stageSet);
      stages.sort((a, b) => {
        const ai = order.indexOf(a), bi = order.indexOf(b);
        if (ai === -1 && bi === -1) return a.localeCompare(b);
        if (ai === -1) return 1;
        if (bi === -1) return -1;
        return ai - bi;
      });
      return stages;
    }
    function groupEventsByDate(events) {
      const grouped = {};
      for (const ev of events) {
        if (!grouped[ev.date]) grouped[ev.date] = [];
        grouped[ev.date].push(ev);
      }
      return grouped;
    }
    // For a stage, build a list of event blocks with startIdx, span, and overlap info
    function calcStageBlocks(stageEvents, slots, slotMinutes) {
      // Sort by start time
      stageEvents = stageEvents.slice().sort((a,b) => timeToMinutes(padTime(a.start)) - timeToMinutes(padTime(b.start)));
      // For each event, determine startIdx, span (in slots)
      const blocks = [];
      for (const ev of stageEvents) {
        const startM = timeToMinutes(padTime(ev.start));
        const endM = timeToMinutes(padTime(ev.end));
        let startIdx = slots.findIndex(s => timeToMinutes(s) === startM);
        if (startIdx === -1) {
          // Find nearest slot before event start
          startIdx = slots.findIndex(s => timeToMinutes(s) > startM) - 1;
          if (startIdx < 0) startIdx = 0;
        }
        let endIdx = slots.findIndex(s => timeToMinutes(s) >= endM);
        if (endIdx === -1) endIdx = slots.length;
        const span = Math.max(1, endIdx - startIdx);
        blocks.push({ev, startIdx, span});
      }
      // Now, handle overlaps: for each slot, build an array of overlapping events
      const slotOverlaps = Array(slots.length).fill(0).map(()=>[]);
      blocks.forEach((block, idx) => {
        for (let i = block.startIdx; i < block.startIdx + block.span && i < slots.length; ++i) {
          slotOverlaps[i].push(idx);
        }
      });
      // For each block, determine its overlap index (column) and total overlaps
      blocks.forEach((block, idx) => {
        // Find max overlap in the block's range
        let maxOverlap = 1;
        let myCol = 0;
        for (let i = block.startIdx; i < block.startIdx + block.span && i < slots.length; ++i) {
          const overlaps = slotOverlaps[i];
          maxOverlap = Math.max(maxOverlap, overlaps.length);
          myCol = Math.max(myCol, overlaps.indexOf(idx));
        }
        block.overlapIdx = myCol;
        block.overlapCount = maxOverlap;
      });
      return blocks;
    }
    function renderDayGrid(date, events, stages, slotMinutes = 30, dayIdx = 0) {
      const slots = createTimeSlots(events, slotMinutes);
      const stageMap = {};
      stages.forEach(s => stageMap[s] = []);
      for (const ev of events) {
        stageMap[ev.stage].push(ev);
      }
      // For each stage, build block info
      const stageBlocks = {};
      stages.forEach(stage => {
        stageBlocks[stage] = calcStageBlocks(stageMap[stage], slots, slotMinutes);
      });
      // Map: per stage, per slot: which event block index starts here
      const stageSlotBlock = {};
      stages.forEach(stage => {
        stageSlotBlock[stage] = {};
        stageBlocks[stage].forEach((block, i) => {
          stageSlotBlock[stage][block.startIdx] = stageSlotBlock[stage][block.startIdx] || [];
          stageSlotBlock[stage][block.startIdx].push({...block, blockIdx: i});
        });
      });
      // Track for each stage/slot the number of rows to skip due to rowspans
      const stageSkip = {};
      stages.forEach(stage => stageSkip[stage] = 0);
      // HTML
      let html = `<div class="timeline-date">${new Date(date).toLocaleDateString('nl-NL', { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' })}</div>`;
      html += `<div class="timeline-grid-wrap"><div class="timeline-grid" style="--stage-count:${stages.length}" data-date="${date}" data-dayidx="${dayIdx}" id="timeline-grid-${dayIdx}">`;
      // Header row
      html += `<div class="timeline-header"></div>`;
      for (const stage of stages) {
        html += `<div class="timeline-header">${stage.charAt(0).toUpperCase() + stage.slice(1)}</div>`;
      }
      // Slot rows
      for (let row = 0; row < slots.length; ++row) {
        html += `<div class="timeline-time" data-time="${slots[row]}">${slots[row]}</div>`;
        for (const stage of stages) {
          // Rowspan skipping
          if (stageSkip[stage] > 0) {
            stageSkip[stage]--;
            continue;
          }
          const blocksHere = (stageSlotBlock[stage][row] || []);
          if (blocksHere.length > 0) {
            // Overlapping events: render all side by side, each with correct rowspan
            html += `<div class="timeline-cell" style="padding:0; position:relative;">`;
            html += `<div class="event-stack" style="height:100%;">`;
            for (const block of blocksHere) {
              const height = `auto`;
              html += `<div class="timeline-event stage-${stage.toLowerCase()}" style="flex:1 1 0; height:${height}; grid-row: span ${block.span}; z-index:3;" title="${block.ev.title}" data-event-idx="${block.blockIdx}" data-stage="${stage}" data-row="${row}" data-span="${block.span}">
                <div class="event-title">${block.ev.title}</div>
                <div class="event-time">${block.ev.start}${block.ev.end!==block.ev.start?` &ndash; ${block.ev.end}`:''}</div>
                ${block.ev.extra_info?`<div class="event-info">${block.ev.extra_info}</div>`:''}
              </div>`;
              if (block.span > 1) stageSkip[stage] = block.span-1;
            }
            html += `</div></div>`;
          } else {
            html += `<div class="timeline-cell"></div>`;
          }
        }
      }
      html += `</div></div>`;
      return html;
    }
    // For the "now" line
    function setNowLine() {
      const now = new Date();
      const yyyy = now.getFullYear();
      const mm = (now.getMonth()+1).toString().padStart(2,'0');
      const dd = now.getDate().toString().padStart(2,'0');
      const todayStr = `${yyyy}-${mm}-${dd}`;
      // Find grid for today
      const grids = document.querySelectorAll('.timeline-grid');
      grids.forEach(grid => {
        const date = grid.getAttribute('data-date');
        // Remove any existing now-line
        grid.parentElement.querySelectorAll('.now-line').forEach(el=>el.remove());
        if (date !== todayStr) return;
        // Get all slot time divs
        const timeDivs = Array.from(grid.querySelectorAll('.timeline-time'));
        if (timeDivs.length === 0) return;
        // Find position for "now"
        const curMinutes = now.getHours()*60 + now.getMinutes();
        let found = false;
        for (let i = 0; i < timeDivs.length-1; ++i) {
          const slotStart = timeToMinutes(timeDivs[i].dataset.time);
          const slotEnd = timeToMinutes(timeDivs[i+1].dataset.time);
          if (curMinutes >= slotStart && curMinutes < slotEnd) {
            // Interpolate position within slot
            const slotDiv = timeDivs[i];
            const nextSlotDiv = timeDivs[i+1];
            const parentRect = grid.parentElement.getBoundingClientRect();
            const percent = (curMinutes - slotStart) / (slotEnd - slotStart);
            const slotTop = slotDiv.offsetTop;
            const slotHeight = nextSlotDiv.offsetTop - slotDiv.offsetTop;
            const nowTop = slotTop + percent * slotHeight;
            // Insert line
            const line = document.createElement('div');
            line.className = 'now-line';
            line.style.top = nowTop+'px';
            grid.parentElement.appendChild(line);
            found = true;
            break;
          }
        }
        // If after last slot, show at bottom
        if (!found) {
          const lastDiv = timeDivs[timeDivs.length-1];
          const line = document.createElement('div');
          line.className = 'now-line';
          line.style.top = (lastDiv.offsetTop + lastDiv.offsetHeight)+'px';
          grid.parentElement.appendChild(line);
        }
      });
    }
    fetch('events.json')
      .then(r => r.json())
      .then(events => {
        const container = document.getElementById('timeline');
        const grouped = groupEventsByDate(events);
        let html = '';
        let dayIdx = 0;
        Object.entries(grouped).sort(([a], [b]) => a.localeCompare(b)).forEach(([date, evs]) => {
          const stages = getAllStages(evs);
          html += renderDayGrid(date, evs, stages, 30, dayIdx++);
        });
        container.innerHTML = html;
        setTimeout(setNowLine, 200); // Wait for DOM
        setInterval(setNowLine, 60*1000); // Update every minute
      })
      .catch(err => {
        document.getElementById('timeline').innerHTML =
          "<p style='color:red'>Kon evenementen niet laden. Controleer het bestand 'events.json'.</p>";
        console.error(err);
      });
    window.addEventListener('resize', () => setTimeout(setNowLine, 300));
  </script>
</body>
</html>
